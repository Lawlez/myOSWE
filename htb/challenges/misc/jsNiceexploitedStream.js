'use strict';
/** @type {!Array} */
var _0x1d30 = ["utf8", "final", "cGFzc3dvcmRfaXNfdGhlX25hbWVfb2Zfb25lX25wbV9wYWNrYWdl", "length", "charAt", "charCodeAt", "slice", "replace", "substring", "83729c4575f56a8287c0b4e8ee5c33f8cb891ccaddcafb71ef5f7bd067f19d854ab16e0cb22460", "xor", "argv", "log", "crypto", "aes-256-ctr", "createDecipher", "update", "hex"];
(function(data, i) {
  /**
   * @param {number} isLE
   * @return {undefined}
   */
  var write = function(isLE) {
    for (; --isLE;) {
      data["push"](data["shift"]());
    }
  };
  write(++i);
})(_0x1d30, 337);
/**
 * @param {string} level
 * @param {?} ai_test
 * @return {?}
 */
var _0x124e = function(level, ai_test) {
  /** @type {number} */
  level = level - 0;
  var rowsOfColumns = _0x1d30[level];
  return rowsOfColumns;
};
try {
  /**
   * @param {?} file
   * @param {?} algo
   * @param {?} data
   * @return {?}
   */
  var decrypt = function(file, algo, data) {
    var res = crypto[_0x124e("0x2")](algo, data);
    var out = res[_0x124e("0x3")](file, _0x124e("0x4"), _0x124e("0x5"));
    out = out + res[_0x124e("0x6")](_0x124e("0x5"));
    return out;
  };
  var crypto = require(_0x124e("0x0"));
  var algorithm = _0x124e("0x1");
  let deep = 18;
  let params = "";
  let for_future_me = _0x124e("0x7");
  let obj = [];
  for (let i = 0; i < params[_0x124e("0x8")]; i++) {
    let c = params[_0x124e("0x9")](i)[_0x124e("0xa")](0);
    let x = (c & 3) << 3 | c >> 2;
    obj["push"](x);
  }
  let o = +new Date + "," + obj[_0x124e("0xb")](0, deep)["toString"]()[_0x124e("0xc")](/,/g, "")[_0x124e("0xd")](0, deep);
  let noxc = _0x124e("0xe");
  let _decryptors = global;
  let key = _decryptors["process"];
  /** @type {function(?, ?, ?): ?} */
  _decryptors[_0x124e("0xf")] = decrypt;
  throw [key[_0x124e("0x10")][2] || o, algorithm, _decryptors, noxc];
} catch (_0x59227e) {
  try {
    let previousState = _0x59227e[2][_0x124e("0xf")](_0x59227e[3], _0x59227e[1], _0x59227e[0]);
    console[_0x124e("0x11")](previousState);
  } catch (_0x79425a) {
  }
}
;