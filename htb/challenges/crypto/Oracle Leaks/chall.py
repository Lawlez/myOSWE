import os
import math
from Crypto.Util.number import *
from cryptography.hazmat.primitives.asymmetric import rsa

def get_length(pt):
	res = 0
	if (len(bin(pt)) - 2) % 8 != 0:
		res += 1
	res += (len(bin(pt)) - 2) // 8
	return res

def ceil(a, b):
	return -(-a // b)

class RSA:
	def __init__(self, size):
		
		self.e = 0x10001 # 65537 this seems ok
		print("e:", self.e)
		self.size = size  # size in bytes is crackable 1024

		priv = rsa.generate_private_key(
		 public_exponent=self.e,# 65537
		 key_size=size #1024
		)
		print("Generating key...")
		pub = priv.public_key()
		
		
		self.n = pub.public_numbers().n #public_numbers are not exposed..

		self.d = priv.private_numbers().d
		#print("primes", self.n, self.d)
		self.n_size = ceil(self.size, 8)
		self.B = 2**((self.n_size-1)*8) 


	def pad(self, pt):
		res = 0x02 << 8 * (self.n_size - 2)
		random_pad = os.urandom(self.n_size - 3 - get_length(pt))
		for idx, val in enumerate(random_pad):
			if val == 0:
				val = 1
			res += val << (len(random_pad) - idx + get_length(pt)) * 8
		res += pt
		return res

	def encrypt(self,pt):
		pt = bytes_to_long(pt)
		padded_pt = self.pad(pt)
		ct = pow(padded_pt, self.e, self.n)
		return long_to_bytes(ct).hex()

	def decrypt(self,ct):
		ct = bytes_to_long(ct)
		pt = pow(ct, self.d, self.n)
		return pt


def main():
	FLAG = b'HTB{dummyflag}'
	size = 1024
	tmp = RSA(size)
	flag = tmp.encrypt(FLAG)
	while True:
		try:
			#print(str(b"\x1b]\xc7\xe8\x15\x94\x81\xbf\x14\xe8\x9a\xe9z\xb8m\x82\x0f^?J<F\xbe\t\xcb\xfdf\xb7\xe7\x8f\xe1\x04\x92'\xcb\x11\xefLvB\xd3\x9a\x8e\x1c_\\/\x89yv\xfb.(\x02u\xe8\x8eV\x90[\xec\x1e?6P)\xcd2\x84\x93N\xe9\xa4\xd1\x08\xa8\xd7\x0c\x1c\x8a^\xd3\xf4f\xb1\x9e\xeb\x1f\xbd\xf9\xf1\x0ez\xd1*\xb0,\xe8\xe9\xd5\xe5\xe9\xe0\xe6UbL\x83o1C\x07NN/\x99\x9a\xcb\xd9`K\xec~Y\x13\xbbK\xba\x93\x93\x1a\xea\x97\xd8\xf9\xe8xM$\x04s\xf4L\x1d{qg\xea+\xb1J}\xf6\xf6\x9e\xc6t\xeb\xa2\xb9\xfb\xe4\xfby\xa9h~$\x02P\xda\xf3L+\x1f \xd2{^r2\x1b\xf9\xfa\xf3\xc7\x17\xb0E\xc0N?\xa3 \x9ff\x8c\xe2e,g!L#>\x02\xae*\x94C\xc1\xfez\x07T\xd8\x07\xa7\xf8\x8a\xfd{J\x98\x11\xc4\x19\xa3Y\xd5]\xc1q\x15@".decode("utf-8")))
			print('Please choose:\n'+\
						'1. Get public key.\n'+\
						'2. Get encrypted flag.\n'+\
						'3. Get length.\n'+\
						'> ')
			opt = input()
			
			if opt == '1':
				pub_key = (hex(tmp.n)[2:], hex(tmp.e)[2:])
				print('(n,e): ' + str(pub_key) + '\n')
			elif opt == '2':
				print('Encrypted text: ' + flag + '\n')
			elif opt == '3':
				print('Provide a ciphertext:\n'+\
							'> ')
				ct = input()
				ct = bytes.fromhex(ct)
				pt = tmp.decrypt(ct)
				print('Decrypted text: ' + str(pt) + '\n')
				length = get_length(pt)
				print('Length: ' + str(length) + '\n')
			else:
				print('Wrong option!\n')
				exit(1)
		except Exception as e:
			print(e)
			print('Invalid Input. Exit!')
			exit(1)

	

if __name__ == "__main__":
    main()

	
## python3 RsaCtfTool.py -n 1009952991021025799971029957574856985056534956545649102525310154102984954985248515654569753505449529898101495055495156102489710048101505356485448505199555448100564857515099102985510049555698519954519950102495010254101525757971015750575656559949545448101524952519753102985450564851481014810110251535550985356575197102521005754554910250102535153571005251525498994854565357101975455985451102535055481015354102525548100531011005256495750484910250995010210250515154985452102101102101102575057555748984810110199555755481025248545752985153505353555748539898545710155 -e 65537 --uncipher 55102971014899975355524954531015556485451565110255485698521005153985610052101545798102101505510150565451101485098102989753515655519850102519710199551021015155101511001025710150544997489752575157989810099100985148991025454102545550991015298569857101985199514856975610251515457505256100551005597541005550555198989997495210256559849555010054485755101505350541015649579910152555798975653100561014951519848485048535449545455100519957551029910154989957101101555248544853555498999856102101574853999999571014956481001001005510154489997541019997485310256975154575255555697


## python3 RsaCtfTool.py -n 100514810297102100555453564910153525348539954575310110056495051515697100519754515348102100545653555648531005552564810097515210152102100534910198985552101995797565749541009949485254995454975754579854535050101569799994898579952575297485251541021029852559757995799991015652579848559748504953565310248484910153525399989855569710154501025710297979710153495698505554505457555253985110199559898535299545657994955504997529749494951545756989910256495210210055981015755525598101534857101485598535557505756534810257995257485710053102521015051569848101519849555355 -e 65537 --uncipher 545052100989899979948100525053101100495549515254485499495356571025751554952529853491004949571019756509797985748565551551014898974952995156501005298535251509910149501004810055101100989810010197100481015048981019953559948531025351975110010152985799102561001015755531005556974951509710010153495599100544999495498100495657491015054514899481025151519897554852102559810048975497509852101985355489799495010298509799579956100985610299101995698101505253559956559752544856524952102559710248102102499948984948979749535351102991014997102481025048100555755989755975548565298 --private

#openssl rsautl -decrypt -inkey key -in msg.enc -out flag.txt

#openssl rsautl -decrypt -in $ENCRYPTED -out $PLAINTEXT -inkey keys/privkey.pem

ENCRYPTED="624dbbcac0d425ed17134606c1589f937144b51d119ea82aab908737e0ba14c382d4b5432ce12d0d7edbbdead0e20bec57c05f53a3de4b9cf8de975d78a132ade517cd61c16bd1891e2630c0f333ba704f7bd0a6a2b4eb570ac12fb2ac9c8db8fcec8be2457c87a4608414f7af0ff1c0b10aa1553fce1af0f20d797ba7a7084b"

PLAINTEXT="d30fafd76581e54505c695ed812338ad3a6350fd6857805d7480da34e4fd51ebb74ec9a8916dc1046c66a969b6522e8acc0b9c494a0436ffb47a9c9cce849b07a021585f001e545cbb78ae62f9faaae518b276269745b3ec7bb54c689c1721a4a1113698bcf814fd7be9747be509e07b57929850f9c4909d5f4e238b0e3b1757"